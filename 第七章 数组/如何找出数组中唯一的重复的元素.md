## 如何找出数组中唯一的重复的元素

> ### 被考查系数:★★★



#### 题目描述:

数字1~1000放在含有1001个元素的数组中，其中只有唯一的一个元素值重复，其他数字均只出现一次。设计一个算法，将重复元素找出来，要求每个数组元素只能访问一次。如果不使用辅助存储空间，能否设计一个算法实现?



#### 分析与解答:

看完题目，首先需要做的就是分析题目所要达到的目标及其中的限定条件。从题目的描述可以发现，本题的目标就是在一个有且仅有一个元素值重复的数组中找出这个唯一的重复元素，而限定条件就是，每个数组元素只能访问一次，并且不许使用辅助存储空间。如果题目没有对是否可以使用辅助数组做限制的话，那么最简单的方法就是使用Hash法。



#### 方法一: Hash法

当使用Hash法时，具体过程:首先定义一个长度为1000的Hash数组，将Hash数组中的元素值都初始化为0,然后将原数组中的元素逐一映射到该 Hash数组中。当对应的Hash数组中的值为0时，则置该Hash数组中该处的值为1:当对应的Hash数组中该处的值为1时，则表明该位置的数在原数组中是重复的，输出即可。

实现代码如下:

~~~js
function findDup(array) {
    let len=array.length
    let newarr=[]
    if(!array || len<1){
        return -1
    }
    for (var i = 0; i < 1000; i++) {
        newarr[i] = 0
    }
    for (var i = 0; i < len; i++) {
        if (newarr[array[i]-1]== 0) {
            newarr[array[i]-1]=1
        }else{
            return array[i]
        }
    }
    return -1
}
~~~

**算法性能分析:** 上述方法是一种典型的以空间换时间的方法，它的时间复杂度为O（n），空间复杂度为O（n），很显然，在题目没有明确限制的情况下，上述方法不失为一种好方法。但是由于题目要求不能使用额外的辅助空间，所以上述方法不可取，是否存在其他满足题意的方法呢?



#### 方法二：累加求和法

所谓累加求和法，指的是将数组中的所有N+1 (此处N的值取1000)个元素相加，然后用得到的和减去1+2+3+.+N (此处N的值为1000)的和，得到的差即为重复的元素的值。这点不难证明。

由于1001个数的数据量较大，不方便说明以上算法。为了简化问题，以数组序列[1,3,4,2,5,3]为例。该数组长度为6，除了数字3以外，其他4个数字都没有重复。按照上述方法首先计算数组中所有元素的和sumb, sumb=1+3+4+2+5+3=18, 数组中只包含1~5的数，算1~5共5 个数字的和suma, suma = 1+2+3+4+5=15;所以，重复的数字值为sumb -suma=3, 由于本方法的代码实现较为简单，此处就不提供代码，有兴趣的读者可以自己实现

实现代码如下: 

~~~js
function findDup(array) {
    // 累加函数
    function add(num) {
        if (!num) return num
        return num + add(num - 1)
    }
    suma = add(1000)
    
    // 无序数组所有项的和
    let sumab = array.reduce((accumulator, currentValue) => accumulator + currentValue)
    return sumab - suma
}
~~~

**算法性能分析**： 

上述方法的时间复杂度为O(N), 空间复杂度为0(1)

在使用求和法计算时，需要注意一个问题，即当数据量巨大时，有可能会导致计算结果溢出。以本题为例，1~ 1000范围内的1000个数累加，其和为(1+1000)X 1000/2，即500500，普通的数字型变量能够表示出来，所以，本题中不存在此问题。但如果累加的数值巨大时，就很有可能溢出了。

此处是否还可以继续发散一下，如果累加求和法能够成立，累乘求积法是不是也是可以成立呢?只是累加求积法在使用的过程中很有可能会存在数据越界的情况，如果再由此定义一个大数乘法来，那就有点得不偿失了。所以，求积的方式是理论上成立的，只是在实际的使用过程中可操作性不强而已，一般更 加推荐累加求和法。



#### 方法三：异或法

鉴于求和法存在的局限性，可以采用位运算中异或的方法。根据异或运算的性质可知，当相同元素异或时，其运算结果为0:当相异元素异或时，其运算结果为非0。任何数与数字0进行异或运算，其运算结果为该数。本题中，正好可以使用到此方法，即将数组里的元素连一进行异或运算， 得到的值再与数字1、2、3、.. N进行异或运算，得到的最终结果即为所求的重复元素。

以数组[1,3, 4,2,5, 3]为例。(1^3^4^2^5^3) ^ (1^2^3^4^5) = (1^1)^(2^2) ^ (3^3^3)^(4^4)(5^5)=0^0^3^0^0=3

实现代码如下: 

~~~js
function findDup(array) {
    let len = array.length
    result = 0
    if (!array || len < 1) {
        return -1
    }
    for (let i = 0; i < len; i++) {
        result ^= array[i]
    }
    for (let i = 0; i < len; i++) {
        result ^= i
    }
    return result
}
~~~

**算法性能分析：**

上述方法的时间复杂度为O（n），并且没有申请辅助的储存空间





#### 方法四：数据映射法

~~~js
function findDup(array) {
    let len = array.length
    index = 0
    if (!array || len < 1) {
        return -1
    }
    for (let i = 0; i < len; i++) {
        if (array[i] >= len) {
            return -1
        }
        if (array[index] < 0) {
            break
        }
        array[index] *= -1
        index = -1 * array[index]

    }
    return index
}
~~~

**算法性能分析：**

上述方法的时间复杂度为O（n），并且没有申请辅助的储存空间













